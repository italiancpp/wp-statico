<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Commenti a: Puntatori? Vivi senza!</title>
	<atom:link href="https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/feed/" rel="self" type="application/rss+xml" />
	<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/</link>
	<description></description>
	<lastBuildDate>Mon, 20 Mar 2017 21:21:21 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7.18</generator>
	<item>
		<title>Di: C++11 in Azione (CDays14) &#124; Italian C++ Community</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-55</link>
		<dc:creator><![CDATA[C++11 in Azione (CDays14) &#124; Italian C++ Community]]></dc:creator>
		<pubDate>Sat, 01 Mar 2014 17:26:10 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-55</guid>
		<description><![CDATA[[...] e ownership &#8220;manuale&#8221;. Questo implicherebbe una serie di problemi discussi anche qui. Ma come unire i benefici delle variabili automatiche (e della RAII) con l&#8217;allocazione [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] e ownership &#8220;manuale&#8221;. Questo implicherebbe una serie di problemi discussi anche qui. Ma come unire i benefici delle variabili automatiche (e della RAII) con l&#8217;allocazione [&#8230;]</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: paolo</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-42</link>
		<dc:creator><![CDATA[paolo]]></dc:creator>
		<pubDate>Sat, 07 Sep 2013 08:52:35 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-42</guid>
		<description><![CDATA[Ciao,

a me sembra un buon articolo dall&#039;evidente taglio basic. Lo trasformerei in una serie.
Credo che sarebbe utile.
Puntatori 1, basic
Puntatori 2, cominciamo a vedere polimorfismo (es. una factory che restituisce un StdoutLogger piuttosto che un FileLogger), vediamo anche qualche differenza sul campo fra unique e shared (es: personalmente preferisco che la factory restituisca unique)
poi in altri episodi...vediamo gli altri smart pointers, smart pointers nei container, smart pointers e threading ecc. ecc.

P]]></description>
		<content:encoded><![CDATA[<p>Ciao,</p>
<p>a me sembra un buon articolo dall&#8217;evidente taglio basic. Lo trasformerei in una serie.<br />
Credo che sarebbe utile.<br />
Puntatori 1, basic<br />
Puntatori 2, cominciamo a vedere polimorfismo (es. una factory che restituisce un StdoutLogger piuttosto che un FileLogger), vediamo anche qualche differenza sul campo fra unique e shared (es: personalmente preferisco che la factory restituisca unique)<br />
poi in altri episodi&#8230;vediamo gli altri smart pointers, smart pointers nei container, smart pointers e threading ecc. ecc.</p>
<p>P</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: franco</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-41</link>
		<dc:creator><![CDATA[franco]]></dc:creator>
		<pubDate>Mon, 02 Sep 2013 09:12:32 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-41</guid>
		<description><![CDATA[Ciao CodeVisio,

l&#039;esempio che ti ho postato √® accademico in un senso: nessuno alloca SOLO per allocare. Tutt&#039;altro √® nel mondo reale, t&#039;assicuro. Magari non ne hai mai sentito il bisogno, ma una mole di dati elevata √® all&#039;ordine del giorno soprattutto ora (&quot;big data&quot; √® la nuova buzzword). Proprio ora ho scritto un software che utilizza qualche giga di RAM, fai tu! 

Fosse una mia opinione, ti lascio con il dubbio: perch√© hanno usato &quot;new&quot;? Bastava l&#039;allocazione statica sullo stack?

Non voglio poi aggiungere nulla sul fatto che, se usi solo lo stack, non puoi avere una lista (come gi√† detto da altri), ad esempio, di oggetti derivanti da un unico padre. Se pensi alle GUI, al FEM, alle mesh, insomma ci sono milioni di modi in cui dovresti usare l&#039;heap.

√† plus!

PS. Non vedi &quot;beginner&quot;, quindi confermi che non vedi alla fine dell&#039;articolo la scritta &lt;b&gt;Tags:basic, containers, puntatori, stl&lt;/b&gt;. Puoi dare un riscontro?]]></description>
		<content:encoded><![CDATA[<p>Ciao CodeVisio,</p>
<p>l&#8217;esempio che ti ho postato √® accademico in un senso: nessuno alloca SOLO per allocare. Tutt&#8217;altro √® nel mondo reale, t&#8217;assicuro. Magari non ne hai mai sentito il bisogno, ma una mole di dati elevata √® all&#8217;ordine del giorno soprattutto ora (&#8220;big data&#8221; √® la nuova buzzword). Proprio ora ho scritto un software che utilizza qualche giga di RAM, fai tu! </p>
<p>Fosse una mia opinione, ti lascio con il dubbio: perch√© hanno usato &#8220;new&#8221;? Bastava l&#8217;allocazione statica sullo stack?</p>
<p>Non voglio poi aggiungere nulla sul fatto che, se usi solo lo stack, non puoi avere una lista (come gi√† detto da altri), ad esempio, di oggetti derivanti da un unico padre. Se pensi alle GUI, al FEM, alle mesh, insomma ci sono milioni di modi in cui dovresti usare l&#8217;heap.</p>
<p>√† plus!</p>
<p>PS. Non vedi &#8220;beginner&#8221;, quindi confermi che non vedi alla fine dell&#8217;articolo la scritta <b>Tags:basic, containers, puntatori, stl</b>. Puoi dare un riscontro?</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: marco</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-40</link>
		<dc:creator><![CDATA[marco]]></dc:creator>
		<pubDate>Sat, 31 Aug 2013 13:49:33 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-40</guid>
		<description><![CDATA[&quot;In qualsiasi mestiere si sbaglia. E anche le persone con esperienza sbagliano, meno frequetemente, se si suppone che imparino dai propri sbagli, ma sicuramente sbagliano anche loro.&quot;

Ok, ha senso, ma quindi vuol dire &quot;lasciamo che tutti sbaglino cos√¨ imparano dai loro errori&quot;? Quindi meglio curare che prevenire? Sono d&#039;accordo che sbagliando si impara, ma penso anche che in contesti con responsabilit√† e quattrini (e nel software ne girano parecchi) gli errori a volte si pagano caro e a seconda dei settori possono accadere anche cose parecchio spiacevoli (ops, crash del software per la dialisi). Se alcuni strumenti aiutano a prevenire perch√© non usarli? E quando dico &quot;alcuni&quot; intendo che molte cose, spesso, &quot;fanno brodo&quot;.

Produttivit√†: visto che scrivere software non √® una scienza esatta, la produttivit√† (termine di fabbricazione economica) applicata al software √® un concetto vago, hai ragione. Mi piace pensare alla produttivit√† come una misura di efficienza, ovvero quanto valore riesci a ottenere in quanto tempo. Cos&#039;√® il valore? Questo √® l&#039;elemento &quot;vago&quot; del concetto di produttivit√†. Pu√≤ essere il numero di linee prodotte, pu√≤ essere il numero di bug fixati, i task completati... Dipende dalle metriche con cui lavori, pu√≤ essere deciso dall&#039;alto, pu√≤ essere una convenzione, pu√≤ anche non esistere proprio. In questi termini anche prevenire un errore √® incluso nel fantomatico concetto di produttivit√†. Oppure riuscire a fare una modifica in 2 ore invece che in due giorni. 

Mi trovi in perfetta sintonia quando dici che scrivere software √® un&#039;attivit√† professionale. Mi paragono sempre ad un &quot;artigiano specializzato&quot;. Non dimentichiamo che con buona probabilit√† i sistemi software sono i pi√π grandi manufatti di sempre. Sottolineo manufatti, cio√® scritti a mano da qualcuno. Lasciamo stare generatori di codice e librerie su librerie che astraggono un po&#039; di cose. Ed essere specializzati richiede esperienza, formazione, passione (molti l&#039;hanno persa), saper sbagliare, ... 

Ultima cosa: il software √® comunque un business, le responsabilit√† sono divise, vengono creati diversi layer (tra cui quello di business) e ci lavorano diverse figure professionali. Ha probabilmente senso che esista un business layer che non sappia nulla che sotto ci sono dei puntatori, non lo so. A me piace il controllo del mio software, quindi voglio capire cosa c&#039;√® sotto, per√≤ mi rendo conto che in molti contesti √® complicato. &quot;Aumenterai la produttivit√† e avrai pi√π guadagni&quot; √® molto appetitosa per chi fa business o sta su un layer pi√π alto. Ad esempio, se la ditta X fa piccoli giochini per smartphone, forse comprare un game-engine che fa tutto quello che serve √® una soluzione sensata e pu√≤ garantire guadagni elevati. La domanda √® sempre: dove sei? Dove vuoi arrivare?]]></description>
		<content:encoded><![CDATA[<p>&#8220;In qualsiasi mestiere si sbaglia. E anche le persone con esperienza sbagliano, meno frequetemente, se si suppone che imparino dai propri sbagli, ma sicuramente sbagliano anche loro.&#8221;</p>
<p>Ok, ha senso, ma quindi vuol dire &#8220;lasciamo che tutti sbaglino cos√¨ imparano dai loro errori&#8221;? Quindi meglio curare che prevenire? Sono d&#8217;accordo che sbagliando si impara, ma penso anche che in contesti con responsabilit√† e quattrini (e nel software ne girano parecchi) gli errori a volte si pagano caro e a seconda dei settori possono accadere anche cose parecchio spiacevoli (ops, crash del software per la dialisi). Se alcuni strumenti aiutano a prevenire perch√© non usarli? E quando dico &#8220;alcuni&#8221; intendo che molte cose, spesso, &#8220;fanno brodo&#8221;.</p>
<p>Produttivit√†: visto che scrivere software non √® una scienza esatta, la produttivit√† (termine di fabbricazione economica) applicata al software √® un concetto vago, hai ragione. Mi piace pensare alla produttivit√† come una misura di efficienza, ovvero quanto valore riesci a ottenere in quanto tempo. Cos&#8217;√® il valore? Questo √® l&#8217;elemento &#8220;vago&#8221; del concetto di produttivit√†. Pu√≤ essere il numero di linee prodotte, pu√≤ essere il numero di bug fixati, i task completati&#8230; Dipende dalle metriche con cui lavori, pu√≤ essere deciso dall&#8217;alto, pu√≤ essere una convenzione, pu√≤ anche non esistere proprio. In questi termini anche prevenire un errore √® incluso nel fantomatico concetto di produttivit√†. Oppure riuscire a fare una modifica in 2 ore invece che in due giorni. </p>
<p>Mi trovi in perfetta sintonia quando dici che scrivere software √® un&#8217;attivit√† professionale. Mi paragono sempre ad un &#8220;artigiano specializzato&#8221;. Non dimentichiamo che con buona probabilit√† i sistemi software sono i pi√π grandi manufatti di sempre. Sottolineo manufatti, cio√® scritti a mano da qualcuno. Lasciamo stare generatori di codice e librerie su librerie che astraggono un po&#8217; di cose. Ed essere specializzati richiede esperienza, formazione, passione (molti l&#8217;hanno persa), saper sbagliare, &#8230; </p>
<p>Ultima cosa: il software √® comunque un business, le responsabilit√† sono divise, vengono creati diversi layer (tra cui quello di business) e ci lavorano diverse figure professionali. Ha probabilmente senso che esista un business layer che non sappia nulla che sotto ci sono dei puntatori, non lo so. A me piace il controllo del mio software, quindi voglio capire cosa c&#8217;√® sotto, per√≤ mi rendo conto che in molti contesti √® complicato. &#8220;Aumenterai la produttivit√† e avrai pi√π guadagni&#8221; √® molto appetitosa per chi fa business o sta su un layer pi√π alto. Ad esempio, se la ditta X fa piccoli giochini per smartphone, forse comprare un game-engine che fa tutto quello che serve √® una soluzione sensata e pu√≤ garantire guadagni elevati. La domanda √® sempre: dove sei? Dove vuoi arrivare?</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: raffaele</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-39</link>
		<dc:creator><![CDATA[raffaele]]></dc:creator>
		<pubDate>Sat, 31 Aug 2013 13:03:56 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-39</guid>
		<description><![CDATA[Io non credo sia solo un problema di professionalit√†.
Il software dell&#039;Ariane 5 ha mandato in fumo 500M$ a causa di una exception non gestita (http://www.savive.com/casestudy/ariane5.html)
Il buon senso ci insegna che se si possono prendere delle precauzioni √® meglio farlo perch√© anche il pi√π attento dei professionisti sbaglia, tutto qui.
Al contrario del C, C++ sceglie la strada delle eccezioni su cui si fonda tutta la Standard Library. Questo rende decisamente pi√π infido scrivere codice intrinsecamente a prova di leak.
La soluzione pi√π semplice √® l&#039;adozione del paradigma RAII (http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) che funge come la rete del trapezista. In alcuni casi pu√≤ avere un minimo di overhead ma complessivamente fornisce i benefici impagabili spiegati da Franco.

Il mio punto di vista √® che sia necessario trasmettere il messaggio che gli strumenti di C++ sono molto diversi da quelli del linguaggio C. Io scrivo ancora assembler oggi (ormai poco su PC, molto di pi√π su microcontrollori) ma questo non mi allontana dagli strumenti pi√π evoluti che offre il nuovo standard con in primis unique_ptr e shared_ptr.

Apprezzo l&#039;articolo di Franco proprio perch√© √® necessario far conoscere i nuovi strumenti e dire chiaramente che C++ e C sono due linguaggi molto diversi, poi star√† al lettore decidere se usarli o meno.]]></description>
		<content:encoded><![CDATA[<p>Io non credo sia solo un problema di professionalit√†.<br />
Il software dell&#8217;Ariane 5 ha mandato in fumo 500M$ a causa di una exception non gestita (<a href="http://www.savive.com/casestudy/ariane5.html" rel="nofollow">http://www.savive.com/casestudy/ariane5.html</a>)<br />
Il buon senso ci insegna che se si possono prendere delle precauzioni √® meglio farlo perch√© anche il pi√π attento dei professionisti sbaglia, tutto qui.<br />
Al contrario del C, C++ sceglie la strada delle eccezioni su cui si fonda tutta la Standard Library. Questo rende decisamente pi√π infido scrivere codice intrinsecamente a prova di leak.<br />
La soluzione pi√π semplice √® l&#8217;adozione del paradigma RAII (<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" rel="nofollow">http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization</a>) che funge come la rete del trapezista. In alcuni casi pu√≤ avere un minimo di overhead ma complessivamente fornisce i benefici impagabili spiegati da Franco.</p>
<p>Il mio punto di vista √® che sia necessario trasmettere il messaggio che gli strumenti di C++ sono molto diversi da quelli del linguaggio C. Io scrivo ancora assembler oggi (ormai poco su PC, molto di pi√π su microcontrollori) ma questo non mi allontana dagli strumenti pi√π evoluti che offre il nuovo standard con in primis unique_ptr e shared_ptr.</p>
<p>Apprezzo l&#8217;articolo di Franco proprio perch√© √® necessario far conoscere i nuovi strumenti e dire chiaramente che C++ e C sono due linguaggi molto diversi, poi star√† al lettore decidere se usarli o meno.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: CodeVisio</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-38</link>
		<dc:creator><![CDATA[CodeVisio]]></dc:creator>
		<pubDate>Sat, 31 Aug 2013 01:32:14 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-38</guid>
		<description><![CDATA[Ciao marco,

&quot;Io sono sicuro che tu non abbia mai avuto problemi di questo genere,&quot;
Io ho poche certezze, invidio te che hai certezze riguardo altri che non conosci. 

&quot; il problema √® quando lavori in un team perch√© gli altri purtroppo possono sbagliare&quot;
In qualsiasi mestiere si sbaglia. E anche le persone con esperienza sbagliano, meno frequetemente, se si suppone che imparino dai propri sbagli, ma sicuramente sbagliano anche loro.

&quot;Oppure quando lasci il tuo codice in mano a gente meno in gamba di te, che magari √® molto pi√π lenta a manutenerlo, ecc&quot;
Non c&#039;entra il concetto di essere in gamba. C&#039;entra il concetto di quali cose sai per certo. Il team si forma con il tempo. E&#039; chiaro che un neofita commetter degli sbagli di natura indipendente dal settore e anche (ovviamente) dipendente dal settore. Ma nel team si presuppone che ci siano persone con esperienza pi√π vasta. O, in caso negativo, si presuppone che chi commette uno sbaglio lo riconosca e impari a non ripeterlo.

&quot;Questo solo per dire che nel C++11 ci sono moltissimi strumenti volti a migliorare la produttivit√† singola e di un intero gruppo di lavoro. Se usati bene e nel contesto giusto, gli smart pointer aiutano a scrivere meno codice con anche maggiore livello di sicurezza (e.g. exception safety).&quot;
Non √® una questione dell&#039; X linguaggio, √® una questione di approccio. Io so Y e non so T. Cosa consco per certo? e per averlo messo in pratica? limiti? punti di forza?
Attenzione ad usare la parola &quot;produttivit√†&quot;.

&quot;Un‚Äôultima nota: perch√© usare oggetti allocati sullo heap? Un altro motivo molto semplice: polimorfismo? Classi astratte? Dependency Injection? Puoi ottenere queste cose anche con delle reference, ma il gioco si fa pi√π complicato.&quot;
Stai parlando in generale o di casi particolari? Non ho mai detto che usare la memoria allocata nello heap sia sbagliato o non utile.

Ritorno al concetto di &quot;produttivit√†&quot;.
Cosa vuol dire produttivit√† per marco? la quantit√† di codice scritto per secondo?
O quanto guadgana la tua azienda per codice scritto?
Occhio che quella parola vuol dire tutto come vuol dire nulla, ma putroppo ha un fore senso commerciale.
I puntatoti intelligenti aumentano la mia produvvita√†? sei sicuro? cio√® riesco a produrreo molto pi√π codice di quello che produrrei se non li usassi?
O mi permettono di evitare alcuni errori? (e quindi c&#039;entra poco con la produvvit√† intesa come quantit√† di codice scritto).
Se √® cos√¨, allora posso non ottenere lo stesso effetto se non uso i puntatoiri intelligenti? o serve solo a non farmi pensare a rialsciare la memori allocata, cosa a cui ho pensato quando l&#039;ho allocata?

Siccome il discorso si fa lungo mi limito a dire sottolineare i lseguente fatto.
Mia personale opininone: nel tempo si √® sottovalutao il concetto di professionalit√† nella scrittua di codice. Ci si √® dimenticati che chi scrive codice in teoria √® un professionista con tanto di studi &quot;universitari&quot; (o lavoro professionale) alle spalle. Non √® poi cos√¨ diverso da uno che progetta un ponte su cui passano migliagia di auto al giorno e quindi con tutta una serie di requisiti. Invece, si √® passati da un lavoro professionale con delle responsaibilit√†, il software architech/designer/developer/engineer (o cio√≤ che pi√π ti aggrada), ad un &quot;smanettone&quot; con tutto il rispetto per gli smanettoni.
Come in tutte le professioni ci vuole esperienza (ottenuta con anni di lavoro)per ottenre degli effetti qualitativi alti e teoria. E occorre anche una forte voglia di imparare dagli sbagli. Pensa un po&#039; al software, non del dentista sotto casa, ma a quello  real time che gira sugli aeroplani.
Oppure ribalta il punto di vista: se ti dicessi &quot;non ti preoccupare, marco, ho notato che nel 99% tu non badi a rilasciare la memoria che esplicitamente hai rischiesto di allocare, ci penso io, tu non ti devi preoccupare, pensa ad altro, concentrati sul tuo business layer, vedrai che aumenterai la tua produttivit√† e avrai pi√π guadagni!&quot;. Mi sembra molto pi√† appetibile quest&#039;ultima ipotesi non trovi?

P.S. non mi serve il preambolo diplomatico sul &quot;sicuramente tu sei bravo&quot; etc. Mi accontento dell&#039;opinione sui fatti.]]></description>
		<content:encoded><![CDATA[<p>Ciao marco,</p>
<p>&#8220;Io sono sicuro che tu non abbia mai avuto problemi di questo genere,&#8221;<br />
Io ho poche certezze, invidio te che hai certezze riguardo altri che non conosci. </p>
<p>&#8221; il problema √® quando lavori in un team perch√© gli altri purtroppo possono sbagliare&#8221;<br />
In qualsiasi mestiere si sbaglia. E anche le persone con esperienza sbagliano, meno frequetemente, se si suppone che imparino dai propri sbagli, ma sicuramente sbagliano anche loro.</p>
<p>&#8220;Oppure quando lasci il tuo codice in mano a gente meno in gamba di te, che magari √® molto pi√π lenta a manutenerlo, ecc&#8221;<br />
Non c&#8217;entra il concetto di essere in gamba. C&#8217;entra il concetto di quali cose sai per certo. Il team si forma con il tempo. E&#8217; chiaro che un neofita commetter degli sbagli di natura indipendente dal settore e anche (ovviamente) dipendente dal settore. Ma nel team si presuppone che ci siano persone con esperienza pi√π vasta. O, in caso negativo, si presuppone che chi commette uno sbaglio lo riconosca e impari a non ripeterlo.</p>
<p>&#8220;Questo solo per dire che nel C++11 ci sono moltissimi strumenti volti a migliorare la produttivit√† singola e di un intero gruppo di lavoro. Se usati bene e nel contesto giusto, gli smart pointer aiutano a scrivere meno codice con anche maggiore livello di sicurezza (e.g. exception safety).&#8221;<br />
Non √® una questione dell&#8217; X linguaggio, √® una questione di approccio. Io so Y e non so T. Cosa consco per certo? e per averlo messo in pratica? limiti? punti di forza?<br />
Attenzione ad usare la parola &#8220;produttivit√†&#8221;.</p>
<p>&#8220;Un‚Äôultima nota: perch√© usare oggetti allocati sullo heap? Un altro motivo molto semplice: polimorfismo? Classi astratte? Dependency Injection? Puoi ottenere queste cose anche con delle reference, ma il gioco si fa pi√π complicato.&#8221;<br />
Stai parlando in generale o di casi particolari? Non ho mai detto che usare la memoria allocata nello heap sia sbagliato o non utile.</p>
<p>Ritorno al concetto di &#8220;produttivit√†&#8221;.<br />
Cosa vuol dire produttivit√† per marco? la quantit√† di codice scritto per secondo?<br />
O quanto guadgana la tua azienda per codice scritto?<br />
Occhio che quella parola vuol dire tutto come vuol dire nulla, ma putroppo ha un fore senso commerciale.<br />
I puntatoti intelligenti aumentano la mia produvvita√†? sei sicuro? cio√® riesco a produrreo molto pi√π codice di quello che produrrei se non li usassi?<br />
O mi permettono di evitare alcuni errori? (e quindi c&#8217;entra poco con la produvvit√† intesa come quantit√† di codice scritto).<br />
Se √® cos√¨, allora posso non ottenere lo stesso effetto se non uso i puntatoiri intelligenti? o serve solo a non farmi pensare a rialsciare la memori allocata, cosa a cui ho pensato quando l&#8217;ho allocata?</p>
<p>Siccome il discorso si fa lungo mi limito a dire sottolineare i lseguente fatto.<br />
Mia personale opininone: nel tempo si √® sottovalutao il concetto di professionalit√† nella scrittua di codice. Ci si √® dimenticati che chi scrive codice in teoria √® un professionista con tanto di studi &#8220;universitari&#8221; (o lavoro professionale) alle spalle. Non √® poi cos√¨ diverso da uno che progetta un ponte su cui passano migliagia di auto al giorno e quindi con tutta una serie di requisiti. Invece, si √® passati da un lavoro professionale con delle responsaibilit√†, il software architech/designer/developer/engineer (o cio√≤ che pi√π ti aggrada), ad un &#8220;smanettone&#8221; con tutto il rispetto per gli smanettoni.<br />
Come in tutte le professioni ci vuole esperienza (ottenuta con anni di lavoro)per ottenre degli effetti qualitativi alti e teoria. E occorre anche una forte voglia di imparare dagli sbagli. Pensa un po&#8217; al software, non del dentista sotto casa, ma a quello  real time che gira sugli aeroplani.<br />
Oppure ribalta il punto di vista: se ti dicessi &#8220;non ti preoccupare, marco, ho notato che nel 99% tu non badi a rilasciare la memoria che esplicitamente hai rischiesto di allocare, ci penso io, tu non ti devi preoccupare, pensa ad altro, concentrati sul tuo business layer, vedrai che aumenterai la tua produttivit√† e avrai pi√π guadagni!&#8221;. Mi sembra molto pi√† appetibile quest&#8217;ultima ipotesi non trovi?</p>
<p>P.S. non mi serve il preambolo diplomatico sul &#8220;sicuramente tu sei bravo&#8221; etc. Mi accontento dell&#8217;opinione sui fatti.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: CodeVisio</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-37</link>
		<dc:creator><![CDATA[CodeVisio]]></dc:creator>
		<pubDate>Sat, 31 Aug 2013 00:50:40 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-37</guid>
		<description><![CDATA[Ciao franco,

non mi aspettavo una risposta celere, quindi personalmente non c&#039;√® niente di cui scusarti.
Sar√† l&#039;orario ma non sono riuscito a leggere la nota riguardo la natura &#039;beginner&#039; dell&#039;articolo.

&quot;Saturare lo stack √® molto semplice, come dice Davide! Se per√≤ lo spazio richiesto √® molto esiguo, √® difficile notarlo.&quot;
Certo, se lo fai a posta come esempio √® normale che lo esaurisci. Discorso diverso √® l&#039;uso quotidiano dello stack. Quind, stai parlando di un caso specifico o di una prassi quotidiana?

&quot;Io nel mio lavoro ho bisogno di spazi molto grandi, qualche giga, e lo stack muore (almeno nella mia piattaforma), prova anche tu&quot;
Ripeto, a me √® capito pochisseme volte su codice facente parte di un programma usato da tantissime persone.
Il discorso √® questo, franco.
Se devi fare degli esempi accademici o estremizzare alcuni punti per spiegare un concetto mi va bene, ma se presenti la possibilit√† di esaurire lo stack come se fosse un cosa che pu√≤ capitare, con notevole probabilit√† (coem da tuo articolo), nel lavoro quotidiano (in C++) allora il discorso √® diverso.
il concetto di &quot;variabili piccole o grandi&quot; √® relativo. Cosa vuol dire variabili piccole o grandi per franco? e la misura √® la stessa per sempronio e caio?
Non √® una questione dell&#039;articolo &#039;beginner&#039; o avanzato, √® che se le cose le tieni per te √® un fatt ma se vuoi trasmettere questa tua conoscenza o opinione ad un pubblico potenzialmente vasto devi fare due conti.
Io, personlmante, non punterei sul faftto che l&#039;articolo √® breve o &#039;advanced&#039;, la cosa che conta √® sottolineare che l&#039;√¨informazione da te trasmessa √® una tua opinione o √® un fatto concretto indipendente da valutazioni soggettive.
Io non sarei capace di scrivere un periodo di senso compiuto in italiano e non mi cimento nel farlo, ma se dovessi farlo mi aspetterei di scrivere cose certe.]]></description>
		<content:encoded><![CDATA[<p>Ciao franco,</p>
<p>non mi aspettavo una risposta celere, quindi personalmente non c&#8217;√® niente di cui scusarti.<br />
Sar√† l&#8217;orario ma non sono riuscito a leggere la nota riguardo la natura &#8216;beginner&#8217; dell&#8217;articolo.</p>
<p>&#8220;Saturare lo stack √® molto semplice, come dice Davide! Se per√≤ lo spazio richiesto √® molto esiguo, √® difficile notarlo.&#8221;<br />
Certo, se lo fai a posta come esempio √® normale che lo esaurisci. Discorso diverso √® l&#8217;uso quotidiano dello stack. Quind, stai parlando di un caso specifico o di una prassi quotidiana?</p>
<p>&#8220;Io nel mio lavoro ho bisogno di spazi molto grandi, qualche giga, e lo stack muore (almeno nella mia piattaforma), prova anche tu&#8221;<br />
Ripeto, a me √® capito pochisseme volte su codice facente parte di un programma usato da tantissime persone.<br />
Il discorso √® questo, franco.<br />
Se devi fare degli esempi accademici o estremizzare alcuni punti per spiegare un concetto mi va bene, ma se presenti la possibilit√† di esaurire lo stack come se fosse un cosa che pu√≤ capitare, con notevole probabilit√† (coem da tuo articolo), nel lavoro quotidiano (in C++) allora il discorso √® diverso.<br />
il concetto di &#8220;variabili piccole o grandi&#8221; √® relativo. Cosa vuol dire variabili piccole o grandi per franco? e la misura √® la stessa per sempronio e caio?<br />
Non √® una questione dell&#8217;articolo &#8216;beginner&#8217; o avanzato, √® che se le cose le tieni per te √® un fatt ma se vuoi trasmettere questa tua conoscenza o opinione ad un pubblico potenzialmente vasto devi fare due conti.<br />
Io, personlmante, non punterei sul faftto che l&#8217;articolo √® breve o &#8216;advanced&#8217;, la cosa che conta √® sottolineare che l&#8217;√¨informazione da te trasmessa √® una tua opinione o √® un fatto concretto indipendente da valutazioni soggettive.<br />
Io non sarei capace di scrivere un periodo di senso compiuto in italiano e non mi cimento nel farlo, ma se dovessi farlo mi aspetterei di scrivere cose certe.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: marco</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-36</link>
		<dc:creator><![CDATA[marco]]></dc:creator>
		<pubDate>Tue, 27 Aug 2013 06:54:23 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-36</guid>
		<description><![CDATA[Ciao CodeVisio, vorrei solo commentare la tua prima affermazione:

&quot;&lt;em&gt;Personalmente non ho mai avuto problemi di memoria non rilasciata quando uso i puntatori o se vuoi i raw pointers. Ovviamente devi usarli nel modo corretto. Ma questo dipende da quanto codice scritto male hai alle spalle.&lt;/em&gt;&quot;

Io sono sicuro che tu non abbia mai avuto problemi di questo genere, il problema √® quando lavori in un team perch√© gli altri purtroppo possono sbagliare. Oppure quando lasci il tuo codice in mano a gente meno in gamba di te, che magari √® molto pi√π lenta a manutenerlo, ecc.

Questo solo per dire che nel C++11 ci sono moltissimi strumenti volti a migliorare la produttivit√† singola e di un intero gruppo di lavoro. Se usati bene e nel contesto giusto, gli smart pointer aiutano a scrivere meno codice con anche maggiore livello di sicurezza (e.g. exception safety).

Un&#039;ultima nota: perch√© usare oggetti allocati sullo heap? Un altro motivo molto semplice: polimorfismo? Classi astratte? Dependency Injection? Puoi ottenere queste cose anche con delle reference, ma il gioco si fa pi√π complicato.]]></description>
		<content:encoded><![CDATA[<p>Ciao CodeVisio, vorrei solo commentare la tua prima affermazione:</p>
<p>&#8220;<em>Personalmente non ho mai avuto problemi di memoria non rilasciata quando uso i puntatori o se vuoi i raw pointers. Ovviamente devi usarli nel modo corretto. Ma questo dipende da quanto codice scritto male hai alle spalle.</em>&#8221;</p>
<p>Io sono sicuro che tu non abbia mai avuto problemi di questo genere, il problema √® quando lavori in un team perch√© gli altri purtroppo possono sbagliare. Oppure quando lasci il tuo codice in mano a gente meno in gamba di te, che magari √® molto pi√π lenta a manutenerlo, ecc.</p>
<p>Questo solo per dire che nel C++11 ci sono moltissimi strumenti volti a migliorare la produttivit√† singola e di un intero gruppo di lavoro. Se usati bene e nel contesto giusto, gli smart pointer aiutano a scrivere meno codice con anche maggiore livello di sicurezza (e.g. exception safety).</p>
<p>Un&#8217;ultima nota: perch√© usare oggetti allocati sullo heap? Un altro motivo molto semplice: polimorfismo? Classi astratte? Dependency Injection? Puoi ottenere queste cose anche con delle reference, ma il gioco si fa pi√π complicato.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: marco</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-35</link>
		<dc:creator><![CDATA[marco]]></dc:creator>
		<pubDate>Tue, 27 Aug 2013 06:45:21 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-35</guid>
		<description><![CDATA[Ciao a tutti e grazie per la partecipazione. Vorrei intervenire solo per fare una precisazione: come specificato nei tag di questo articolo, il livello √® &quot;basic&quot; ovvero orientato ad iniziare e non ad essere molto deep. Questo perch√© abbiamo diversi utenti begineer o che stanno provando a ricominciare a programmare in C++ (l&#039;hanno lasciato molto prima del C++11).

Sicuramente in futuro tratteremo anche argomenti pi√π avanzati e ripasseremo per topic gi√† discussi ma con occhio pi√π attento e preciso. Questo articolo, ad esempio, vuole solo essere un&#039;introduzione &quot;leggera&quot; agli smart pointer, al fatto che esistono e i motivi principali per utilizzarli.

Ringrazio nuovamente tutti e, tra l&#039;altro, ricordo che se avete voglia di pubblicare le vostre idee (anche molto avanzate) potete &lt;a href=&quot;http://www.italiancpp.org/articoli/diventa-un-autore/&quot; rel=&quot;nofollow&quot;&gt;diventare autori&lt;/a&gt; e inviarci i vostri contenuti!]]></description>
		<content:encoded><![CDATA[<p>Ciao a tutti e grazie per la partecipazione. Vorrei intervenire solo per fare una precisazione: come specificato nei tag di questo articolo, il livello √® &#8220;basic&#8221; ovvero orientato ad iniziare e non ad essere molto deep. Questo perch√© abbiamo diversi utenti begineer o che stanno provando a ricominciare a programmare in C++ (l&#8217;hanno lasciato molto prima del C++11).</p>
<p>Sicuramente in futuro tratteremo anche argomenti pi√π avanzati e ripasseremo per topic gi√† discussi ma con occhio pi√π attento e preciso. Questo articolo, ad esempio, vuole solo essere un&#8217;introduzione &#8220;leggera&#8221; agli smart pointer, al fatto che esistono e i motivi principali per utilizzarli.</p>
<p>Ringrazio nuovamente tutti e, tra l&#8217;altro, ricordo che se avete voglia di pubblicare le vostre idee (anche molto avanzate) potete <a href="http://www.italiancpp.org/articoli/diventa-un-autore/" rel="nofollow">diventare autori</a> e inviarci i vostri contenuti!</p>
]]></content:encoded>
	</item>
	<item>
		<title>Di: franco</title>
		<link>https://www.italiancpp.org/2013/08/23/puntatori-vivi-senza/#comment-34</link>
		<dc:creator><![CDATA[franco]]></dc:creator>
		<pubDate>Tue, 27 Aug 2013 06:43:10 +0000</pubDate>
		<guid isPermaLink="false">http://www.italiancpp.org/?p=1070#comment-34</guid>
		<description><![CDATA[Non posso che concordare con quello che hai scritto. L&#039;articolo non va assolutamente nei dettagli (ho usato un tag &quot;basic&quot; apposta), per questo usiamo i commenti, per mettere dettagli che l&#039;articolo non pu√≤ contenere! :)]]></description>
		<content:encoded><![CDATA[<p>Non posso che concordare con quello che hai scritto. L&#8217;articolo non va assolutamente nei dettagli (ho usato un tag &#8220;basic&#8221; apposta), per questo usiamo i commenti, per mettere dettagli che l&#8217;articolo non pu√≤ contenere! üôÇ</p>
]]></content:encoded>
	</item>
</channel>
</rss>
